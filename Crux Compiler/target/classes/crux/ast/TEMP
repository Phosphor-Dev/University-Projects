---NEED TO FIX---
visitArrayDecl DONE
visitFunctionDefn DONE
visitCallStmt DONE
visitExpr0 MAYBE

package crux.ast;

import crux.ast.types.IntType;
import crux.ast.types.VoidType;
import crux.ir.insts.BinaryOperator;
import crux.pt.CruxBaseVisitor;
import crux.pt.CruxParser;
import org.antlr.v4.runtime.ParserRuleContext;

import java.io.PrintStream;
import java.util.ArrayList;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where Decls will be by DeclVisitor Class Statements will be resolved by StmtVisitor Class Expressions will
 * be resolved by ExprVisitor Class
 */

public final class ParseTreeLower {
  private final DeclVisitor declVisitor = new DeclVisitor();
  private final StmtVisitor stmtVisitor = new StmtVisitor();
  private final ExprVisitor exprVisitor = new ExprVisitor();

  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());
  }

  /**
   *
   * @return True if any errors
   */
  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }


  /**
   * Lower top-level parse tree to AST
   *
   * @return a {@link DeclarationList} object representing the top-level AST.
   */
  public DeclarationList lower(CruxParser.ProgramContext program) {
    ArrayList<Declaration> list = new ArrayList<Declaration> ();

    for(CruxParser.DeclContext context: program.declList().decl()){
      Declaration node = context.accept(declVisitor);
      list.add(node);
    }
    Position pos = makePosition(program);
    return new DeclarationList(pos, list);
  }


  /**
   * Lower stmt list by lower individual stmt into AST.
   *
   * @return a {@link StatementList} AST object.
   */
  private StatementList lower(CruxParser.StmtListContext stmtList) {
    ArrayList<Statement> list = new ArrayList<Statement> ();
    for(CruxParser.StmtContext context: stmtList.stmt()){ //
      Statement node = context.accept(stmtVisitor);
      list.add(node);
    }
    Position pos = makePosition(stmtList);
    return new StatementList(pos, list);
  }


  /**
   * Similar to {@link #lower(CruxParser.StmtListContext)}, but handles symbol table as well.
   *
   * @return a {@link StatementList} AST object.
   */
  private StatementList lower(CruxParser.StmtBlockContext stmtBlock) {
    symTab.enter();
    StatementList statement = lower(stmtBlock.stmtList());
    symTab.exit();
    return statement;
  }


  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */
  private final class DeclVisitor extends CruxBaseVisitor<Declaration> {
    /**
     * Visit a parse tree var decl and create an AST {@link VariableDeclaration}
     * @return an AST {@link VariableDeclaration}
     */
    @Override
    public VariableDeclaration visitVarDecl(CruxParser.VarDeclContext ctx) {
      String name = ctx.IDENTIFIER().getText();
      String type = ctx.type().getText();
      Type type1 = null;
      switch (type) {
        case "int" :
          type1 = new IntType();
          break;
        case "bool":
          type1 = new BoolType();
          break;
        case "void":
          type1 = new VoidType();
          break;
      }
      return new VariableDeclaration(makePosition(ctx), symTab.add(makePosition(ctx), name, type1));
    }

    /**
     * Visit a parse tree array decl and creates an AST {@link ArrayDeclaration}
     * @return an AST {@link ArrayDeclaration}
     */
    @Override
    public Declaration visitArrayDecl(CruxParser.ArrayDeclContext ctx) {

    }


    /**
     * Visit a parse tree function definition and create an AST {@link FunctionDefinition}
     * @return an AST {@link FunctionDefinition}
     */
    @Override
    public Declaration visitFunctionDefn(CruxParser.FunctionDefnContext ctx) {
      Position pos = makePosition(ctx);
      String name = ctx.IDENTIFIER().getText();
      Type ftype = null;
      String ctype = ctx.type().getText();
      switch (ctype) {
        case "int" :
          ftype = new IntType();
          break;
        case "bool":
          ftype = new BoolType();
          break;
      }
      if (symTab.lookup(pos, name) == null) {
        symTab.add(pos, name, ftype);
      }
      ArrayList<Symbol> list = new ArrayList<>();
      for (CruxParser.ParamContext context: ctx.paramList().param()) {
        String ptype = context.type().getText();
        Type type1 = null;
        switch (ptype) {
          case "int" :
            ftype = new IntType();
            break;
          case "bool":
            ftype = new BoolType();
            break;
        }
        Symbol node = symTab.add(pos, symTab.add(pos, context.IDENTIFIER().getText(), type1));
        list.add(node);
      }
      StatementList statements = lower(ctx.stmtBlock());
      return new FunctionDefinition(pos, symTab.add(pos, name, ftype),list, statements);
    }
  }


  /**
   * A parse tree visitor to create AST nodes derived from {@link Statement}
   */

  private final class StmtVisitor extends CruxBaseVisitor<Statement> {
    /**
     * Visit a parse tree var decl and create an AST {@link VariableDeclaration}. Since
     * {@link VariableDeclaration} is both {@link Declaration} and {@link Statement}, we simply
     * delegate this to {@link DeclVisitor#visitArrayDecl(CruxParser.ArrayDeclContext)} which we
     * implement earlier.
     *
     * @return an AST {@link VariableDeclaration}
     */
    @Override
    public Statement visitVarDecl(CruxParser.VarDeclContext ctx) {
      String ctxType = ctx.type().getText();
      String name = ctx.IDENTIFIER().getText();
      Type type = null;
      switch (ctxType) {
        case "int" :
          type = new IntType();
          break;
        case "bool":
          type = new BoolType();
      }
      return new VariableDeclaration(makePosition(ctx), symTab.add(makePosition(ctx), name), name, type));
    }

    /**
     * Visit a parse tree assignment stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */
    @Override
    public Statement visitAssignStmt(CruxParser.AssignStmtContext ctx) {
      CruxParser.Expr0Context lhsCtx = ctx.expr0();
      Expression lhsExpression = lhsCtx.accept(exprVisitor);
      CruxParser.Expr0Context rhsCtx = ctx.expr0();
      Expression rhsExpression = rhsCtx.accept(exprVisitor);
      Position pos = makePosition(ctx);
      return new Assignment(pos, lhsExpression, rhsExpression);
    }

    /**
     * Visit a parse tree assignment no semi stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */
     @Override
     public Statement visitAssignStmtNoSemi(CruxParser.AssignStmtNoSemiContext ctx) {
       CruxParser.Expr0Context rhsCtx = ctx.expr0();
       Expression rhsExpression = rhsCtx.accept(exprVisitor);
       Expression lhsExpression = ctx.designator().IDENTIFIER().accept(exprVisitor) ;
       Position pos = makePosition(ctx);
       return new Assignment(pos, lhsExpression, rhsExpression);
     }

    /**
     * Visit a parse tree call stmt and create an AST {@link Call}. Since {@link Call} is both
     * {@link Expression} and {@link Statementt}, we simply delegate this to
     * {@link ExprVisitor#visitCallExpr(CruxParser.CallExprContext)} that we will implement later.
     *
     * @return an AST {@link Call}
     */
    @Override
    public Statement visitCallStmt(CruxParser.CallStmtContext ctx) {
      Position pos = makePosition(ctx);
      String name = ctx.callExpr().IDENTIFIER().getText();
      return Call(pos, symTab.lookup(pos, name), ctx.callExpr().exprList());
    }


    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
     * shows partial implementations that visit the then block and else block recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     *
     * @return an AST {@link IfElseBranch}
     */
    @Override
    public Statement visitIfStmt(CruxParser.IfStmtContext ctx) {
      Expression condition = ctx.expr0().accept(exprVisitor);
      if (ctx.ELSE() != null){
        StatementList thenBlock = lower(ctx.stmtBlock(0));
        StatementList elseBlock = lower(ctx.stmtBlock(1));
        return new IfElseBranch(makePosition(ctx), condition, thenBlock, elseBlock);
      } else {
        StatementList thenBlock = lower(ctx.stmtBlock(0));
        return new IfElseBranch(makePosition(ctx), condition, thenBlock, null);
      }
    }


    /**
     * Visit a parse tree for loop and create an AST {@link For}. You're going to use a similar
     * technique as {@link #visitIfStmt(CruxParser.IfStmtContext)} to decompose this construction.
     *
     * @return an AST {@link For}
     */

    @Override
    public Statement visitForStmt(CruxParser.ForStmtContext ctx) {
      Position pos = makePosition(ctx);

      Expression lhsExpression = ctx.assignStmt().designator().accept(exprVisitor);
      CruxParser.Expr0Context rhsCtx = ctx.assignStmt().expr0();
      Expression rhsExpression = rhsCtx.accept(exprVisitor);

      Expression lhsExpression1 = ctx.assignStmtNoSemi().designator().accept(exprVisitor);
      CruxParser.Expr0Context rhsCtx1 = ctx.assignStmtNoSemi().expr0();
      Expression rhsExpression1 = rhsCtx.accept(exprVisitor);

      Assignment init = new Assignment(pos, lhsExpression, rhsExpression);
      Assignment init2 = new Assignment(pos, lhsExpression1, rhsExpression1);
      return new For(pos, init, ctx.expr0().accept(exprVisitor), init2, lower(ctx.stmtBlock()));
    }


    /**
     * Visit a parse tree return stmt and create an AST {@link Return}. Here we show a simple
     * example of how to lower a simple parse tree construction.
     *
     * @return an AST {@link Return}
     */
    @Override
    public Statement visitReturnStmt(CruxParser.ReturnStmtContext ctx) {
      return new Return(makePosition(ctx), ctx.expr0().accept(exprVisitor));
    }


    /**
     * Creates a Break node
     */
     @Override
     public Statement visitBreakStmt(CruxParser.BreakStmtContext ctx) {
       return new Break(makePosition(ctx));
     }

  }

  private final class ExprVisitor extends CruxBaseVisitor<Expression> {
    /**
     * Parse Expr0 to OpExpr Node Parsing the expr should be exactly as described in the grammar
     */
    @Override
    public Expression visitExpr0(CruxParser.Expr0Context ctx) {
      if (ctx.op0() == null) {
        return ctx.expr1().accept(exprVisitor);
      } else {
        CruxParser.Expr1Context lhsCtx = ctx.expr1(0);
        CruxParser.Op0Context op0 = ctx.op0();
        CruxParser.Expr1Context rhsCtx = ctx.expr1(1);
        Operation op = null;
        String opStr = op0.getText();
        switch (opStr) {
          case ">=":
            op = Operation.GE;
            break;
          case "<=":
            op = Operation.LE;
            break;
          case "!=":
            op = Operation.NE;
            break;
          case "==":
            op = Operation.EQ;
            break;
          case ">":
            op = Operation.GT;
            break;
          case "<":
            op = Operation.LT;
            break;
        }
        Expression lhs = lhsCtx.accept(exprVisitor);
        Expression rhs = rhsCtx.accept(exprVisitor);
        Position pos = makePosition(ctx);
        return new OpExpr(pos, op, lhs, rhs);
      }
    }

    /**
     * Parse Expr1 to OpExpr Node Parsing the expr should be exactly as described in the grammar
     */
    @Override
    public Expression visitExpr1(CruxParser.Expr1Context ctx) {
      if (ctx.op1() == null) {
        return ctx.expr2().accept(exprVisitor);
      } else {
        CruxParser.Expr1Context lhsCtx = ctx.expr1();
        CruxParser.Op1Context op1 = ctx.op1();
        CruxParser.Expr2Context rhsCtx = ctx.expr2();
        Operation op = null;
        String opStr = op1.getText();
        switch (opStr) {
          case ">=":
            op = Operation.ADD;
            break;
          case "<=":
            op = Operation.SUB;
            break;
          case "!=":
            op = Operation.LOGIC_OR;
            break;
        }
        Expression lhs = lhsCtx.accept(exprVisitor);
        Expression rhs = rhsCtx.accept(exprVisitor);
        Position pos = makePosition(ctx);
        return new OpExpr(pos, op, lhs, rhs);
      }
    }

    /**
     * Parse Expr2 to OpExpr Node Parsing the expr should be exactly as described in the grammar
     */
    @Override
    public Expression visitExpr2(CruxParser.Expr2Context ctx) {
      if (ctx.op2() == null) {
        return ctx.expr3().accept(exprvisitor);
      } else {
        CruxParser.Expr2Context lhsCtx = ctx.expr2();
        CruxParser.Op2Context op2 = ctx.op2();
        CruxParser.Expr3Context rhsCtx = ctx.expr3();
        Operation op = null;
        String opStr = op2.getText();
        switch (opStr) {
          case "*":
            op = Operation.MULT;
            break;
          case "/":
            op = Operation.DIV;
            break;
          case "&&":
            op = Operation.LOGIC_AND;
            break;
        }
        Expression lhs = lhsCtx.accept(exprVisitor);
        Expression rhs = rhsCtx.accept(exprVisitor);
        Position pos = makePosition(ctx);
        return new OpExpr(pos, op, lhs, rhs);
      }
    }

    /**
     * Parse Expr3 to OpExpr Node Parsing the expr should be exactly as described in the grammar
     */
    @Override
    public Expression visitExpr3(CruxParser.Expr3Context ctx) {
      if (ctx.expr3() != null) {
        CruxParser.Expr3Context lhsCtx = ctx.expr3();
        Expression lhsExpression = lhsCtx.accept(exprVisitor);
        return new OpExpr(makePosition(ctx), OpExpr.Operation.LOGIC_NOT, lhsExpression, null);
      } else if (ctx.expr0() != null) {
          return visitExpr0(ctx.expr0());
      } else if (ctx.designator() != null) {
          return visitDesignator(ctx.designator());
      } else if (ctx.callExpr() != null) {
          return visitCallExpr(ctx.callExpr());
      } else {
        return visitLiteral(ctx.literal());
      }
    }

    /**
     * Create a Call Node
     */
    @Override
    public Call visitCallExpr(CruxParser.CallExprContext ctx) {
      Position pos = makePosition(ctx);
      String name = ctx.IDENTIFIER().getText();
      SymbolTable.Symbol symbol = symTab.lookup(pos, name);
      ArrayList<Expression> list = new ArrayList<>();
      for (CruxParser.Expr0Context context : ctx.exprList().expr0()) {
        Expression node =  context.accept(exprVisitor);
        list.add(node);
      }
      return new Call(pos, symbol, list);
    }

    /**
     * visitDesignator will check for a name or ArrayAccess FYI it should account for the case when
     * the designator was dereferenced
     */
    @Override
    public Expression visitDesignator(CruxParser.DesignatorContext ctx) {
      Position pos = makePosition(ctx);
      if (ctx.IDENTIFIER() != null) {
        String name = ctx.IDENTIFIER().getText();
        return new VarAccess(pos, symTab.lookup(pos, name));
      } else if (ctx.expr0() != null) {
        String name1 = ctx.IDENTIFIER().getText();
        return new ArrayAccess(pos, symTab.lookup(pos, name1), visitExpr0(ctx.expr0()));
      }
      return null;
      //Return either VarAccess or ArrayAccess
    }

    /**
     * Create a Literal Node
     */
    @Override
    public Expression visitLiteral(CruxParser.LiteralContext ctx) {
      if (ctx.INTEGER() != null) {
        return new LiteralInt(makePosition(ctx), Long.parseLong(ctx.INTEGER().getText()));
      } else if (ctx.TRUE() != null) {
        return new LiteralInt(makePosition(ctx), true);
      } else if (ctx.FALSE() != null) {
        return new LiteralInt(makePosition(ctx), false);
      } else {
        return null;
      }
    }
  }
